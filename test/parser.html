<!doctype html>
<html>
  <head>
    <title>Parser Test Suite Page</title>
    <style>
      input+span:hover { border-bottom: 1px solid red; cursor: pointer; }
      #cfg-menu { position: fixed; top:0; left: 0; background-color: white; }
      div { font-size: 11px; font-family: monospace; }
      .red { background-color: red; color: white; }
      .green { background-color: green; color: white; }
      hr { margin: 0; padding: 0; font-size: 1px; }
    </style>
  </head>
  <body>
    (c) qfox.nl<br/>
    Testing parser:<br/>
    <script src="../src/uni.js"></script>
    <script src="../src/tok.js"></script>
    <script src="../src/par.js"></script>
    <script src="tests.js"></script>
    <script>
      new function(){
        var hidePasses = true;

        var out = document.createElement('pre');
        document.body.appendChild(out);
        var debug = function () {
          var f = document.createElement('div');
          f.innerHTML = Array.prototype.slice.call(arguments, 0).join(' ');
          out.appendChild(f);
        };

        debug("Running test suite on parser...", good.length, "tests");
        debug(' ');

        var TESTINPUT = 0;
        var TOKENCOUNT = 1;
        var PARSERCOUNT = 1;
        var REGEXHINT = 2;
        var DESCWITHOUTREGEXHINT = 2;
        var DESCWITHREGEXHINT = 3;

        var NEWLINESTATE_N = 0;
        var NEWLINESTATE_R = 1;
        var NEWLINESTATE_RN = 2;
        var NEWLINESTATE_PS = 3;
        var NEWLINESTATE_LS = 4;
        var NEWLINESTATES = ['\\n', '\\r', '\\r\\n', '\\u2028', '\\u2029'];
        // note: first is `\n`, we dont need to replace anything for that, so it's `false`
        var NEWLINEFORSTATE = [false, '\r', '\r\n', '\u2028', '\u2029'];

        var start = Date.now();
        var ok = 0;
        var fail = 0;
        var newlineState = NEWLINESTATE_N;
        for (var i = 0; i < good.length; ++i) {
          var currentNewline = NEWLINEFORSTATE[newlineState];
          var test = good[i];

          var input = test[TESTINPUT];
          var outputLen = test[TOKENCOUNT].length ? test[TOKENCOUNT][PARSERCOUNT] : test[TOKENCOUNT];
          var regexHints = test[DESCWITHREGEXHINT] ? test[DESCWITHOUTREGEXHINT] : []; // if flags, then len=4
          var desc = test[DESCWITHREGEXHINT] || test[DESCWITHOUTREGEXHINT];

          // test all valid newlines
          if (currentNewline) {
            input = input.replace(/\n/g, currentNewline);
            desc += ' (newline used: '+NEWLINESTATES[newlineState]+')';
          }
          var crashed = false;
          try {
            var par = new Par(input);
            par.run();
          } catch (e) {
            console.error('Crash for', input);
            console.error(e);
            crashed = e;
          }

          var tcount = par.tok.tokenCountAll -1; // inc asi, ex eof

          if (crashed) {
            debug('<b class="red">Test crashed:</span>', desc, '(' + crashed.toString() + ')');
            debug('<b>' + input.replace(/&/g, '&amp;').replace(/</g, '&lt;') + '</b>');
            debug('<br/>');
            ++fail;
          } else if (tcount == outputLen) {
            if (!hidePasses) debug('<span class="green">Test ' + i + ' ok:</span>', desc);
            if (!hidePasses) debug('<b>' + input.replace(/&/g, '&amp;').replace(/</g, '&lt;') + '</b>');
            if (!hidePasses) debug('<br/>');
            ++ok;
          } else {
            debug('<b class="red">Test ' + i + ' failed:</span>', desc, '(found', tcount, 'expected', outputLen + ')'), console.log(desc, par);
            debug('<b>' + input.replace(/&/g, '&amp;').replace(/</g, '&lt;') + '</b>');
            debug('<br/>');
            ++fail;
          }

          // test also with other newlines if there's a newline in this test, no \r, and we've not yet tested all newlines for this test
          var testNewlines = newlineState || (input.indexOf('\n') >= 0 && input.indexOf('\r') < 0);
          if (testNewlines && NEWLINEFORSTATE[++newlineState]) --i; // repeat with different newline
          else newlineState = NEWLINESTATE_N;
        }

        debug("<h1>These tests should fail:</h1><br/>");

        newlineState = NEWLINESTATE_N;
        for (var i = 0; i < bad.length; ++i) {
          var currentNewline = NEWLINEFORSTATE[newlineState];
          var test = bad[i];
          if (!test) console.warn("Probably missing a comma...");
          var input = test[0];
          var desc = test[1];

          // test all valid newlines
          if (currentNewline) {
            input = input.replace(/\n/g, currentNewline);
            desc += ' (newline used: '+NEWLINESTATES[newlineState]+')';
          }

          var crashed = false;
          try {
            var par = new Par(input);
            par.run();
            console.warn("Did not fail:", desc);
          } catch (e) {
            var msg = e.toString();
            crashed = true;
          }

          if (crashed) {
            if (!hidePasses) debug('<span class="green">Test ' + i + ' should fail and did:</span>', desc, '<small style="color:#ccc;white-space:nowrap;overflow:hidden;">'+msg+'</small>');
            if (!hidePasses) debug('<b>' + input.replace(/&/g, '&amp;').replace(/</g, '&lt;') + '</b>');
            if (!hidePasses) debug('<br/>');
            ++ok;
          } else {
            debug('<b class="red">Test ' + i + ' did not fail but should:</span>', desc);
            debug('<b>' + input.replace(/&/g, '&amp;').replace(/</g, '&lt;') + '</b>');
            debug('<br/>');
            ++fail;
          }

          // test also with other newlines if there's a newline in this test, no \r, and we've not yet tested all newlines for this test
          var testNewlines = newlineState || (input.indexOf('\n') >= 0 && input.indexOf('\r') < 0);
          if (testNewlines && NEWLINEFORSTATE[++newlineState]) --i; // repeat with different newline
          else newlineState = NEWLINESTATE_N;
        }

        debug("<h1>These tests should optionally fail</h1>");

        newlineState = NEWLINESTATE_N;
        for (var i = 0; i < optional.length; ++i) {
          var testGroup = optional[i];
          debug("<h2>"+testGroup.optionName+"</h2>");
          var cases = testGroup.cases;
          for (var j=0; j < cases.length; ++j) {
            var currentNewline = NEWLINEFORSTATE[newlineState];
            var test = cases[j];
            if (!test) console.warn("Probably missing a comma...");

            var input = test[0];
            var desc = test[1];

            var failed = false;

            // test all valid newlines
            if (currentNewline) {
              input = input.replace(/\n/g, currentNewline);
              desc += ' (newline used: '+NEWLINESTATES[newlineState]+')';
            }

            var passedWhenFalse = false;
            var passedWhenTrue = false;
            var trueFailMessage = '';
            var falseFailMessage = '';

            try {
              var options = {};
              options[testGroup.optionName] = true;
              Par.parse(input, options);
              failed = !testGroup.expectedWhenOn;
              passedWhenTrue = true;
            } catch (e) {
              failed = testGroup.expectedWhenOn;
              passedWhenTrue = false;
              trueFailMessage = ': <small style="color:#ccc;">'+e.toString()+'</small>';
            }

            try {
              var options = {};
              options[testGroup.optionName] = false;
              Par.parse(input, options);
              failed = !testGroup.expectedWhenOff;
              passedWhenFalse = true;
            } catch (e) {
              failed = testGroup.expectedWhenOff;
              passedWhenFalse = false;
              falseFailMessage = ': <small style="color:#ccc;">'+e.toString()+'</small>';
            }

            if (passedWhenTrue !== testGroup.expectedWhenOn || passedWhenFalse !== testGroup.expectedWhenOff) {
              debug('<b class="red">Test ' + j + ' did not properly pass/fail:</span>', desc);
              debug('flag=true:  expect:'+(testGroup.expectedWhenOn?'pass':'fail')+' was:'+(passedWhenTrue?'pass':'fail')+trueFailMessage);
              debug('flag=false: expect:'+(testGroup.expectedWhenOff?'pass':'fail')+' was:'+(passedWhenFalse?'pass':'fail')+falseFailMessage);
              debug('<b>' + input.replace(/&/g, '&amp;').replace(/</g, '&lt;') + '</b>');
              debug('<br/>');
              ++fail;
            } else {
              if (!hidePasses) debug('<span class="green">Test ' + i + ' properly passed and failed:</span>', desc);
              if (!hidePasses) debug('flag=true:  expect:'+(testGroup.expectedWhenOn?'pass':'fail')+' was:'+(passedWhenTrue?'pass':'fail')+trueFailMessage);
              if (!hidePasses) debug('flag=false: expect:'+(testGroup.expectedWhenOff?'pass':'fail')+' was:'+(passedWhenFalse?'pass':'fail')+falseFailMessage);
              if (!hidePasses) debug('<b>' + input.replace(/&/g, '&amp;').replace(/</g, '&lt;') + '</b>');
              if (!hidePasses) debug('<br/>');
              ++ok;
            }

            // test also with other newlines if there's a newline in this test, no \r, and we've not yet tested all newlines for this test
            var testNewlines = newlineState || (input.indexOf('\n') >= 0 && input.indexOf('\r') < 0);
            if (testNewlines && NEWLINEFORSTATE[++newlineState]) --j; // repeat with different newline
            else newlineState = NEWLINESTATE_N;
          }

          // also check if all good tests still pass with this flag set, because they should
          for (var ogi = 0; ogi < good.length; ++ogi) {
            var currentNewline = NEWLINEFORSTATE[newlineState];
            var test = good[ogi];
            if (!test) console.warn("Probably missing a comma...");

            var input = test[0];
            var desc = test[2];

            var failed = false;

            // test all valid newlines
            if (currentNewline) {
              input = input.replace(/\n/g, currentNewline);
              desc += ' (newline used: '+NEWLINESTATES[newlineState]+')';
            }

            var passedWhenFalse = false;
            var passedWhenTrue = false;
            var trueFailMessage = '';
            var falseFailMessage = '';

            try {
              var options = {};
              options[testGroup.optionName] = true;
              Par.parse(input, options);
              passedWhenTrue = true;
            } catch (e) {
              passedWhenTrue = false;
              trueFailMessage = ': <small style="color:#ccc;">'+e.toString()+'</small>';
            }

            try {
              var options = {};
              options[testGroup.optionName] = false;
              Par.parse(input, options);
              passedWhenFalse = true;
            } catch (e) {
              passedWhenFalse = false;
              falseFailMessage = ': <small style="color:#ccc;">'+e.toString()+'</small>';
            }

            if (!passedWhenTrue || !passedWhenFalse) {
              debug('<b class="red">Always good test ' + ogi + ' failed under either flag value:</span>', desc);
              debug('flag=true:  expect:pass, was:'+(passedWhenTrue?'pass':'fail')+trueFailMessage);
              debug('flag=false: expect:pass, was:'+(passedWhenFalse?'pass':'fail')+falseFailMessage);
              debug('<b>' + input.replace(/&/g, '&amp;').replace(/</g, '&lt;') + '</b>');
              debug('<br/>');
              ++fail;
            } else {
              // dont report good ones, they're just dupes at this point
              // also dont count them towards total tests...
              // ++ok;
            }

            // test also with other newlines if there's a newline in this test, no \r, and we've not yet tested all newlines for this test
            var testNewlines = newlineState || (input.indexOf('\n') >= 0 && input.indexOf('\r') < 0);
            if (testNewlines && NEWLINEFORSTATE[++newlineState]) --ogi; // repeat with different newline
            else newlineState = NEWLINESTATE_N;
          }

          // also check if all bad tests still fail with this flag set, because they should
          for (var obi = 0; obi < bad.length; ++obi) {
            var currentNewline = NEWLINEFORSTATE[newlineState];
            var test = good[obi];
            if (!test) console.warn("Probably missing a comma...");

            var input = test[0];
            var desc = test[2];

            var failed = false;

            // test all valid newlines
            if (currentNewline) {
              input = input.replace(/\n/g, currentNewline);
              desc += ' (newline used: '+NEWLINESTATES[newlineState]+')';
            }

            var passedWhenFalse = false;
            var passedWhenTrue = false;
            var trueFailMessage = '';
            var falseFailMessage = '';

            try {
              var options = {};
              options[testGroup.optionName] = true;
              Par.parse(input, options);
              passedWhenTrue = true;
            } catch (e) {
              passedWhenTrue = false;
            }

            try {
              var options = {};
              options[testGroup.optionName] = false;
              Par.parse(input, options);
              passedWhenFalse = true;
            } catch (e) {
              passedWhenFalse = false;
            }

            if (!passedWhenTrue || !passedWhenFalse) {
              debug('<b class="red">Always bad test ' + ogi + ' passed under either flag value:</span>', desc);
              debug('flag=true:  expect:fail, was:'+(passedWhenTrue?'pass':'fail'));
              debug('flag=false: expect:fail, was:'+(passedWhenFalse?'pass':'fail'));
              debug('<b>' + input.replace(/&/g, '&amp;').replace(/</g, '&lt;') + '</b>');
              debug('<br/>');
              ++fail;
            } else {
              // dont report good ones, they're just dupes at this point
              // also dont count them towards total tests...
              // ++ok;
            }

            // test also with other newlines if there's a newline in this test, no \r, and we've not yet tested all newlines for this test
            var testNewlines = newlineState || (input.indexOf('\n') >= 0 && input.indexOf('\r') < 0);
            if (testNewlines && NEWLINEFORSTATE[++newlineState]) --ogi; // repeat with different newline
            else newlineState = NEWLINESTATE_N;
          }

        }

        debug("Parser test suite finished (" + (Date.now() - start) + ' ms). ok:' + ok + ', fail:' + fail);
        console.log("Parser test suite finished (" + (Date.now() - start) + ' ms). ok:' + ok + ', fail:' + fail);
      };
    </script>
  </body>
</html>
